<!DOCTYPE html>
<html>
<head>
  <!--
    If you are serving your web app in a path other than the root, change the
    href value below to reflect the base path you are serving from.

    The path provided below has to start and end with a slash "/" in order for
    it to work correctly.

    For more details:
    * https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base

    This is a placeholder for base href that will be replaced by the value of
    the `--base-href` argument provided to `flutter build`.
  -->
  <base href="$FLUTTER_BASE_HREF">

  <meta charset="UTF-8">
  <meta content="IE=Edge" http-equiv="X-UA-Compatible">
  <meta name="description" content="A new Flutter project.">

  <!-- iOS meta tags & icons -->
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="apple-mobile-web-app-title" content="roc_app">
  <link rel="apple-touch-icon" href="icons/Icon-192.png">

  <!-- Favicon -->
  <link rel="icon" type="image/png" href="favicon.png"/>

  <title>roc_app</title>
  <link rel="manifest" href="manifest.json">
</head>
<body>
  <script>
    // CRITICAL TEST: This must execute immediately - if you don't see this log, scripts aren't running
    console.log('=== SCRIPT EXECUTION TEST ===');
    console.log('Script execution timestamp:', Date.now());
    window._scriptTestExecuted = true;
    
    // Environment variable diagnostic - runs immediately to help debug deployment issues
    (function() {
      // This script runs before Flutter loads to provide early diagnostics
      // Note: We can't directly check Dart compile-time constants from JS,
      // but we can provide helpful diagnostics and check for common issues
      console.log('[EnvDiagnostic] Starting environment variable diagnostic...');
      console.log('[EnvDiagnostic] Current URL:', window.location.href);
      console.log('[EnvDiagnostic] User Agent:', navigator.userAgent);
      
      // Store diagnostic info for Flutter to access
      window.rocEnvDiagnostic = {
        timestamp: new Date().toISOString(),
        url: window.location.href,
        userAgent: navigator.userAgent,
        isProduction: window.location.hostname !== 'localhost' && !window.location.hostname.includes('127.0.0.1'),
      };
      
      console.log('[EnvDiagnostic] Diagnostic info stored in window.rocEnvDiagnostic');
      console.log('[EnvDiagnostic] Production mode:', window.rocEnvDiagnostic.isProduction);
      
      // Check if we're on Firebase hosting
      const isFirebase = window.location.hostname.includes('firebaseapp.com') || 
                         window.location.hostname.includes('.web.app');
      console.log('[EnvDiagnostic] Firebase hosting:', isFirebase);
      
      if (isFirebase) {
        console.log('[EnvDiagnostic] Running on Firebase - environment variables must be embedded at build time');
        console.log('[EnvDiagnostic] Build command should be: flutter build web --release --dart-define-from-file=env/prod.json --base-href=/');
      }
    })();
    
    // Debug helper - only log in development (when not in production build)
    // In production builds, Flutter sets window.flutterConfiguration which we can check
    const isDebugMode = !window.flutterConfiguration || window.flutterConfiguration.debug === true;
    function debugLog() {
      if (isDebugMode && console && console.log) {
        console.log.apply(console, arguments);
      }
    }
    function debugError() {
      if (isDebugMode && console && console.error) {
        console.error.apply(console, arguments);
      }
    }
    
    // Immediately log that we're about to define rocPlaces
    console.log('[rocPlaces] Starting rocPlaces initialization...');
    
    // Set a flag immediately to verify script execution
    window._rocPlacesScriptExecuting = true;
    window._rocPlacesScriptStartTime = Date.now();
    
    try {
      window.rocPlaces = (function () {
        console.log('[rocPlaces] rocPlaces IIFE executing...');
      let scriptLoader = null;
      let placesLibraryPromise = null;
      let sessionToken = null;
      let cachedKey = '';

      function loadScript(apiKey) {
        if (!apiKey) {
          return Promise.reject('Missing Maps API key.');
        }
        // Check if Maps API is already fully loaded
        if (window.google && window.google.maps && window.google.maps.Map && window.google.maps.places) {
          return Promise.resolve();
        }
        if (scriptLoader) {
          return scriptLoader;
        }
        scriptLoader = new Promise(function (resolve, reject) {
          const script = document.createElement('script');
          script.src =
            'https://maps.googleapis.com/maps/api/js?key=' +
            encodeURIComponent(apiKey) +
            '&libraries=places&v=weekly';
          script.async = true;
          script.defer = true;
          script.onload = function () {
            // Wait for the full Maps API to be initialized, not just the script tag
            let attempts = 0;
            const maxAttempts = 50; // 5 seconds max
            const pollInterval = 100; // Check every 100ms
            
            function checkMapsAPI() {
              // Verify the main Maps API is available AND Map is a constructor function
              if (window.google && 
                  window.google.maps && 
                  window.google.maps.Map &&
                  typeof window.google.maps.Map === 'function' &&
                  window.google.maps.LatLng &&
                  typeof window.google.maps.LatLng === 'function') {
                debugLog('[rocPlaces] Google Maps API fully initialized after', attempts, 'attempts');
                debugLog('[rocPlaces] Map constructor available:', typeof window.google.maps.Map);
                debugLog('[rocPlaces] LatLng constructor available:', typeof window.google.maps.LatLng);
                resolve();
                return;
              }
              
              attempts++;
              if (attempts >= maxAttempts) {
                debugError('[rocPlaces] Google Maps API not initialized after script load');
                debugError('[rocPlaces] window.google:', !!window.google);
                debugError('[rocPlaces] window.google.maps:', !!window.google?.maps);
                debugError('[rocPlaces] window.google.maps.Map:', !!window.google?.maps?.Map);
                debugError('[rocPlaces] window.google.maps.Map type:', typeof window.google?.maps?.Map);
                debugError('[rocPlaces] window.google.maps.LatLng:', !!window.google?.maps?.LatLng);
                reject(new Error('Google Maps API failed to initialize after script load'));
                return;
              }
              
              setTimeout(checkMapsAPI, pollInterval);
            }
            
            // Start checking immediately
            checkMapsAPI();
          };
          script.onerror = function (error) {
            debugError('[rocPlaces] Script load error:', error);
            reject(error);
          };
          document.head.appendChild(script);
        });
        return scriptLoader;
      }

      async function ensurePlacesReady(apiKey) {
        if (!apiKey) {
          debugError('[rocPlaces] Missing Maps API key');
          return Promise.reject('Missing Maps API key.');
        }
        try {
          cachedKey = apiKey;
          await loadScript(apiKey);
          debugLog('[rocPlaces] Script loaded, verifying main Maps API is ready...');
          
          // CRITICAL: Wait for main Maps API to be fully initialized BEFORE loading Places
          // This ensures Map, LatLng, and other core classes are available
          let mainApiAttempts = 0;
          const mainApiMaxAttempts = 50;
          const mainApiPollInterval = 100;
          
          while (mainApiAttempts < mainApiMaxAttempts) {
            if (window.google && 
                window.google.maps && 
                window.google.maps.Map &&
                typeof window.google.maps.Map === 'function' &&
                window.google.maps.LatLng &&
                typeof window.google.maps.LatLng === 'function') {
              debugLog('[rocPlaces] Main Maps API confirmed ready after', mainApiAttempts, 'attempts');
              break;
            }
            await new Promise(function(resolve) {
              setTimeout(resolve, mainApiPollInterval);
            });
            mainApiAttempts++;
            if (mainApiAttempts % 10 === 0) {
              debugLog('[rocPlaces] Waiting for main Maps API... attempt', mainApiAttempts);
            }
          }
          
          if (mainApiAttempts >= mainApiMaxAttempts) {
            debugError('[rocPlaces] Main Maps API not ready after waiting');
            debugError('[rocPlaces] window.google.maps.Map:', !!window.google?.maps?.Map);
            debugError('[rocPlaces] window.google.maps.Map type:', typeof window.google?.maps?.Map);
            return Promise.reject('Main Maps API (Map, LatLng) not ready');
          }
          
          debugLog('[rocPlaces] Main Maps API ready, checking for importLibrary...');
          
          // Now that main Maps API is ready, we can safely use importLibrary if available
          if (
            window.google &&
            window.google.maps &&
            window.google.maps.importLibrary
          ) {
            debugLog('[rocPlaces] importLibrary available, loading places library...');
            if (!placesLibraryPromise) {
              placesLibraryPromise = window.google.maps.importLibrary('places');
            }
            await placesLibraryPromise;
            debugLog('[rocPlaces] importLibrary completed');
          } else {
            debugLog('[rocPlaces] importLibrary not available, using traditional loading');
          }
          
          // Wait for places library to be available (with retry mechanism)
          // This handles the async loading delay when using loading=async
          let attempts = 0;
          const maxAttempts = 50; // 5 seconds max (50 * 100ms)
          const pollInterval = 100; // Check every 100ms
          
          while (!window.google?.maps?.places && attempts < maxAttempts) {
            await new Promise(function(resolve) {
              setTimeout(resolve, pollInterval);
            });
            attempts++;
            if (attempts % 10 === 0) {
              debugLog('[rocPlaces] Waiting for places library... attempt', attempts);
            }
          }
          
          // Verify both main Maps API and Places are available
          if (
            !window.google ||
            !window.google.maps ||
            !window.google.maps.Map ||
            typeof window.google.maps.Map !== 'function' ||
            !window.google.maps.places
          ) {
            debugError('[rocPlaces] Google Maps API not fully loaded after', attempts, 'attempts');
            debugError('[rocPlaces] window.google:', !!window.google);
            debugError('[rocPlaces] window.google.maps:', !!window.google?.maps);
            debugError('[rocPlaces] window.google.maps.Map:', !!window.google?.maps?.Map);
            debugError('[rocPlaces] window.google.maps.Map type:', typeof window.google?.maps?.Map);
            debugError('[rocPlaces] window.google.maps.places:', !!window.google?.maps?.places);
            return Promise.reject('Google Maps API not fully loaded (Map or Places missing)');
          }
          
          debugLog('[rocPlaces] Places library loaded successfully after', attempts, 'attempts');
          debugLog('[rocPlaces] Main Maps API confirmed ready (Map constructor available)');
          
          // Verify Geocoder is available (needed for reverse geocoding)
          if (!window.google.maps.Geocoder) {
            console.warn('[rocPlaces] Geocoder not available - reverse geocoding will not work');
            console.warn('[rocPlaces] This may indicate the Geocoding API is not enabled');
          } else {
            debugLog('[rocPlaces] Geocoder available for reverse geocoding');
          }
          
          // Check if at least one API is available
          const hasNewAutocomplete = !!window.google.maps.places.AutocompleteSuggestion;
          const hasLegacyAutocomplete = !!window.google.maps.places.AutocompleteService;
          const hasNewPlace = !!window.google.maps.places.Place;
          const hasLegacyPlace = !!window.google.maps.places.PlacesService;
          
          debugLog('[rocPlaces] API availability:', {
            mainMapsAPI: !!window.google.maps.Map,
            geocoder: !!window.google.maps.Geocoder,
            newAutocomplete: hasNewAutocomplete,
            legacyAutocomplete: hasLegacyAutocomplete,
            newPlace: hasNewPlace,
            legacyPlace: hasLegacyPlace,
          });
          
          if (!hasNewAutocomplete && !hasLegacyAutocomplete) {
            debugError('[rocPlaces] No autocomplete API available');
            return Promise.reject('Autocomplete API not available');
          }
          if (!hasNewPlace && !hasLegacyPlace) {
            debugError('[rocPlaces] No place details API available');
            return Promise.reject('Place details API not available');
          }
        } catch (error) {
          debugError('[rocPlaces] Error initializing Places API:', error);
          return Promise.reject('Failed to initialize Places API: ' + error.message);
        }
      }

      function getSessionToken() {
        if (
          !sessionToken &&
          window.google &&
          window.google.maps &&
          window.google.maps.places &&
          window.google.maps.places.AutocompleteSessionToken
        ) {
          sessionToken = new google.maps.places.AutocompleteSessionToken();
        }
        return sessionToken;
      }

      function resetSessionToken() {
        sessionToken = null;
      }

      function mapPrediction(prediction) {
        if (!prediction) {
          console.warn('[rocPlaces] mapPrediction received null/undefined prediction');
          return null;
        }
        const structured =
          prediction.structured_formatting || prediction.structuredFormatting;
        const result = {
          description: prediction.description || '',
          place_id: prediction.place_id || prediction.placeId || '',
          structured_formatting: structured
            ? {
                main_text:
                  structured.main_text || structured.mainText || '',
                secondary_text:
                  structured.secondary_text || structured.secondaryText || '',
              }
            : null,
        };
        if (!result.place_id || !result.description) {
          console.warn('[rocPlaces] mapPrediction: missing place_id or description', prediction);
        }
        return result;
      }

      function mapAddressComponents(components) {
        return (components || []).map(function (component) {
          return {
            long_name: component.long_name,
            short_name: component.short_name,
            types: component.types || [],
          };
        });
      }

      function reverseGeocode(lat, lng, onSuccess, onError) {
        // Callback-based approach to avoid promise conversion issues with minified code
        try {
          if (!lat || !lng) {
            const error = 'Missing latitude or longitude';
            debugError('[rocPlaces] ' + error);
            if (onError && typeof onError === 'function') {
              onError(error);
            }
            return;
          }
          if (!cachedKey) {
            const error = 'Places API not initialized';
            debugError('[rocPlaces] ' + error);
            if (onError && typeof onError === 'function') {
              onError(error);
            }
            return;
          }
          
          // Call ensurePlacesReady and handle with callbacks
          ensurePlacesReady(cachedKey)
            .then(function() {
              debugLog('[rocPlaces] Reverse geocoding for coordinates:', lat, lng);
              
              // Verify main Maps API is available
              if (!window.google || !window.google.maps) {
                const error = 'Google Maps API not available';
                debugError('[rocPlaces] Google Maps API not available for reverse geocoding');
                if (onError && typeof onError === 'function') {
                  onError(error);
                }
                return;
              }
              
              // Verify Geocoder is available and is a constructor function
              if (!window.google.maps.Geocoder) {
                const error = 'Geocoder not available. Please enable Geocoding API in Google Cloud Console.';
                debugError('[rocPlaces] Geocoder not available');
                debugError('[rocPlaces] Please ensure:');
                debugError('[rocPlaces] 1. Geocoding API is enabled in Google Cloud Console');
                debugError('[rocPlaces] 2. API key has access to Geocoding API');
                debugError('[rocPlaces] 3. Billing is enabled for your Google Cloud project');
                if (onError && typeof onError === 'function') {
                  onError(error);
                }
                return;
              }
              
              if (typeof window.google.maps.Geocoder !== 'function') {
                const error = 'Geocoder is not properly initialized';
                debugError('[rocPlaces] Geocoder is not a constructor function');
                debugError('[rocPlaces] Geocoder type:', typeof window.google.maps.Geocoder);
                if (onError && typeof onError === 'function') {
                  onError(error);
                }
                return;
              }
              
              debugLog('[rocPlaces] Geocoder verified as constructor function, using for reverse geocoding');
              
              try {
                // Verify GeocoderStatus enum is available
                if (!google.maps.GeocoderStatus) {
                  const error = 'GeocoderStatus not available';
                  debugError('[rocPlaces] GeocoderStatus enum not available');
                  if (onError && typeof onError === 'function') {
                    onError(error);
                  }
                  return;
                }
                
                debugLog('[rocPlaces] Creating Geocoder instance...');
                const geocoder = new google.maps.Geocoder();
                if (!geocoder) {
                  const error = 'Failed to create Geocoder instance';
                  debugError('[rocPlaces] Failed to create Geocoder instance');
                  if (onError && typeof onError === 'function') {
                    onError(error);
                  }
                  return;
                }
                
                debugLog('[rocPlaces] Geocoder instance created successfully');
                debugLog('[rocPlaces] Preparing geocode request for coordinates:', lat, lng);
                
                const request = {
                  location: { lat: parseFloat(lat), lng: parseFloat(lng) },
                };
                debugLog('[rocPlaces] Geocode request:', JSON.stringify(request));
                
                debugLog('[rocPlaces] Calling geocoder.geocode()...');
                geocoder.geocode(
                  request,
                  function (results, status) {
                    debugLog('[rocPlaces] ===== Geocode callback fired =====');
                    const statusStr = status !== undefined && status !== null ? String(status) : 'undefined/null';
                    debugLog('[rocPlaces] Callback status: ' + statusStr + ' (type: ' + typeof status + ')');
                    const resultsStr = results !== undefined && results !== null 
                      ? (Array.isArray(results) ? 'Array(' + results.length + ')' : typeof results)
                      : 'undefined/null';
                    debugLog('[rocPlaces] Callback results: ' + resultsStr + ' (type: ' + typeof results + ', isArray: ' + Array.isArray(results) + ')');
                    const resultsLength = results && Array.isArray(results) ? results.length : (results ? 'not an array' : 'null/undefined');
                    debugLog('[rocPlaces] Callback results length: ' + resultsLength);
                    
                    if (results && Array.isArray(results) && results.length > 0) {
                      const firstResult = JSON.stringify(results[0], null, 2);
                      debugLog('[rocPlaces] First result: ' + firstResult);
                      const formattedAddr = results[0].formatted_address || 'missing';
                      debugLog('[rocPlaces] First result formatted_address: ' + formattedAddr);
                      const addrComponents = results[0].address_components ? JSON.stringify(results[0].address_components, null, 2) : 'missing';
                      debugLog('[rocPlaces] First result address_components: ' + addrComponents);
                    } else {
                      debugLog('[rocPlaces] No results or empty array');
                      if (results && !Array.isArray(results)) {
                        const resultsJson = JSON.stringify(results, null, 2);
                        debugLog('[rocPlaces] Results is not an array (type: ' + typeof results + '): ' + resultsJson);
                      }
                    }
                    
                    // Check status
                    const statusOK = google.maps.GeocoderStatus.OK;
                    const statusOKStr = String(statusOK);
                    debugLog('[rocPlaces] GeocoderStatus.OK value: ' + statusOKStr);
                    debugLog('[rocPlaces] Status comparison (status === OK): ' + (status === statusOK));
                    debugLog('[rocPlaces] Status comparison (status == OK): ' + (status == statusOK));
                    debugLog('[rocPlaces] Status comparison (String(status) === String(OK)): ' + (String(status) === String(statusOK)));
                    
                    if (
                      status !== google.maps.GeocoderStatus.OK ||
                      !results ||
                      !Array.isArray(results) ||
                      results.length === 0
                    ) {
                      const errorStatusStr = status !== undefined && status !== null ? String(status) : 'undefined/null';
                      debugError('[rocPlaces] Reverse geocode failed - Status: ' + errorStatusStr + ' (type: ' + typeof status + ')');
                      const errorResultsStr = results !== undefined && results !== null 
                        ? (Array.isArray(results) ? 'Array(' + results.length + ')' : JSON.stringify(results, null, 2))
                        : 'undefined/null';
                      debugError('[rocPlaces] Results: ' + errorResultsStr);
                      const errorResultsLength = results && Array.isArray(results) ? results.length : (results ? 'not an array' : 'null/undefined');
                      debugError('[rocPlaces] Results length: ' + errorResultsLength);
                      
                      let errorMessage = status || 'UNKNOWN_ERROR';
                      if (status === google.maps.GeocoderStatus.ZERO_RESULTS) {
                        errorMessage = 'No results found for coordinates: ' + lat + ', ' + lng;
                        debugError('[rocPlaces] No results found for coordinates: ' + lat + ', ' + lng);
                      } else if (status === google.maps.GeocoderStatus.OVER_QUERY_LIMIT) {
                        errorMessage = 'Geocoding quota exceeded';
                        debugError('[rocPlaces] Geocoding quota exceeded');
                      } else if (status === google.maps.GeocoderStatus.REQUEST_DENIED) {
                        errorMessage = 'Geocoding request denied - check API key permissions';
                        debugError('[rocPlaces] Geocoding request denied - check API key permissions');
                      } else if (status === google.maps.GeocoderStatus.INVALID_REQUEST) {
                        errorMessage = 'Invalid request - check coordinates: ' + lat + ', ' + lng;
                        debugError('[rocPlaces] Invalid request - check coordinates: ' + lat + ', ' + lng);
                      } else {
                        debugError('[rocPlaces] Unknown status: ' + errorStatusStr);
                      }
                      if (onError && typeof onError === 'function') {
                        onError(errorMessage);
                      }
                      return;
                    }
                    
                    debugLog('[rocPlaces] Processing successful geocode result...');
                    const result = results[0];
                    
                    // Extract address components
                    const addressComponents = mapAddressComponents(
                      result.address_components || []
                    );
                    const addrComponentsJson = JSON.stringify(addressComponents, null, 2);
                    debugLog('[rocPlaces] Mapped address components: ' + addrComponentsJson);
                    
                    const location =
                      result.geometry && result.geometry.location
                        ? {
                            lat:
                              typeof result.geometry.location.lat === 'function'
                                ? result.geometry.location.lat()
                                : result.geometry.location.lat,
                            lng:
                              typeof result.geometry.location.lng === 'function'
                                ? result.geometry.location.lng()
                                : result.geometry.location.lng,
                          }
                        : { lat: parseFloat(lat), lng: parseFloat(lng) };
                    
                    const locationJson = JSON.stringify(location, null, 2);
                    debugLog('[rocPlaces] Extracted location: ' + locationJson);
                    
                    const mappedResult = {
                      formatted_address: result.formatted_address || '',
                      geometry: { location: location },
                      address_components: addressComponents,
                    };
                    const mappedResultJson = JSON.stringify(mappedResult, null, 2);
                    debugLog('[rocPlaces] Final mapped result: ' + mappedResultJson);
                    debugLog('[rocPlaces] Reverse geocode returning successfully');
                    if (onSuccess && typeof onSuccess === 'function') {
                      onSuccess(mappedResult);
                    }
                  }
                );
                debugLog('[rocPlaces] geocode() call completed, waiting for callback...');
              } catch (geocoderError) {
                debugError('[rocPlaces] Error creating or using Geocoder:', geocoderError);
                debugError('[rocPlaces] Error type:', typeof geocoderError);
                debugError('[rocPlaces] Error message:', geocoderError?.message);
                debugError('[rocPlaces] Error stack:', geocoderError?.stack);
                const errorMessage = geocoderError && geocoderError.message ? geocoderError.message : (geocoderError ? String(geocoderError) : 'Unknown error');
                if (onError && typeof onError === 'function') {
                  onError(errorMessage);
                }
              }
            })
            .catch(function(error) {
              debugError('[rocPlaces] Error in reverseGeocode:', error);
              const errorMessage = error && error.message ? error.message : (error ? String(error) : 'Unknown error');
              if (onError && typeof onError === 'function') {
                onError(errorMessage);
              }
            });
        } catch (error) {
          // Synchronous error - call error callback immediately
          debugError('[rocPlaces] Synchronous error in reverseGeocode wrapper:', error);
          const errorMessage = error && error.message ? error.message : (error ? String(error) : 'Unknown error');
          if (onError && typeof onError === 'function') {
            onError(errorMessage);
          }
        }
      }

      return {
        ensureLoaded: function (apiKey, onSuccess, onError) {
          // Callback-based approach to avoid promise conversion issues with minified code
          // This ensures reliable interop between Dart and JavaScript in production builds
          try {
            if (!apiKey) {
              const error = 'Missing Maps API key';
              debugError('[rocPlaces] ' + error);
              if (onError && typeof onError === 'function') {
                onError(error);
              }
              return;
            }
            
            // Call ensurePlacesReady and handle with callbacks
            ensurePlacesReady(apiKey)
              .then(function() {
                debugLog('[rocPlaces] ensurePlacesReady completed successfully');
                if (onSuccess && typeof onSuccess === 'function') {
                  onSuccess();
                }
              })
              .catch(function(error) {
                debugError('[rocPlaces] ensurePlacesReady failed:', error);
                const errorMessage = error && error.message ? error.message : (error ? String(error) : 'Unknown error');
                if (onError && typeof onError === 'function') {
                  onError(errorMessage);
                }
              });
          } catch (error) {
            // Synchronous error - call error callback immediately
            debugError('[rocPlaces] Synchronous error in ensureLoaded wrapper:', error);
            const errorMessage = error && error.message ? error.message : (error ? String(error) : 'Unknown error');
            if (onError && typeof onError === 'function') {
              onError(errorMessage);
            }
          }
        },
        reverseGeocode: function (lat, lng, onSuccess, onError) {
          reverseGeocode(lat, lng, onSuccess, onError);
        },
        autocomplete: function (query, onSuccess, onError) {
          // Callback-based approach to avoid promise conversion issues with minified code
          try {
            if (!query || !query.trim()) {
              if (onSuccess && typeof onSuccess === 'function') {
                onSuccess([]);
              }
              return;
            }
            if (!cachedKey) {
              const error = 'Places API not initialized';
              debugError('[rocPlaces] ' + error);
              if (onError && typeof onError === 'function') {
                onError(error);
              }
              return;
            }
            
            // Call ensurePlacesReady and handle with callbacks
            ensurePlacesReady(cachedKey)
              .then(function() {
                debugLog('[rocPlaces] Starting autocomplete for query:', query);
                debugLog('[rocPlaces] AutocompleteSuggestion available:', !!window.google.maps.places.AutocompleteSuggestion);
                debugLog('[rocPlaces] AutocompleteService available:', !!window.google.maps.places.AutocompleteService);
                
                // Use new AutocompleteSuggestion API if available, fallback to legacy
                if (
                  window.google.maps.places.AutocompleteSuggestion &&
                  window.google.maps.places.AutocompleteSuggestion
                    .fetchAutocompleteSuggestions
                ) {
                  try {
                    debugLog('[rocPlaces] Attempting to use AutocompleteSuggestion API');
                    const request = {
                      input: query,
                      sessionToken: getSessionToken(),
                      includedRegionCodes: ['za'],
                    };
                    window.google.maps.places.AutocompleteSuggestion.fetchAutocompleteSuggestions(request)
                      .then(function(response) {
                        debugLog('[rocPlaces] AutocompleteSuggestion raw response:', response);
                        debugLog('[rocPlaces] Response type:', typeof response);
                        debugLog('[rocPlaces] Response keys:', response ? Object.keys(response) : 'null');
                        debugLog('[rocPlaces] Has suggestions property:', !!(response && response.suggestions));
                        debugLog('[rocPlaces] Suggestions type:', response?.suggestions ? typeof response.suggestions : 'N/A');
                        debugLog('[rocPlaces] Suggestions is array:', Array.isArray(response?.suggestions));
                        debugLog('[rocPlaces] Suggestions length:', response?.suggestions?.length ?? 0);
                        
                        if (response && response.suggestions) {
                          const suggestionCount = response.suggestions.length;
                          console.log('[rocPlaces] Processing', suggestionCount, 'suggestions');
                          
                          if (suggestionCount > 0) {
                            const firstSuggestion = response.suggestions[0];
                            console.log('[rocPlaces] First suggestion raw:', JSON.stringify(firstSuggestion, null, 2));
                            console.log('[rocPlaces] First suggestion keys:', Object.keys(firstSuggestion));
                          }
                          
                          const mapped = response.suggestions.map(function (suggestion, index) {
                            debugLog('[rocPlaces] Suggestion', index, 'raw:', suggestion);
                            debugLog('[rocPlaces] Suggestion', index, 'type:', typeof suggestion);
                            debugLog('[rocPlaces] Suggestion', index, 'keys:', suggestion ? Object.keys(suggestion) : 'null');
                            
                            // Try different possible response structures
                            const placePrediction = suggestion.placePrediction || suggestion;
                            debugLog('[rocPlaces] Suggestion', index, 'placePrediction:', placePrediction);
                            
                            // Add detailed logging for first item
                            if (index === 0) {
                              console.log('[rocPlaces] First suggestion structure:', {
                                suggestion: suggestion,
                                placePrediction: placePrediction,
                                hasText: !!(suggestion.text || placePrediction?.text),
                                hasDescription: !!(suggestion.description || placePrediction?.description),
                                hasPlaceId: !!(suggestion.placeId || suggestion.place_id || placePrediction?.placeId || placePrediction?.place_id)
                              });
                            }
                            
                            // Handle text property - could be string or object with .text property
                            let textValue = '';
                            if (placePrediction?.text) {
                              if (typeof placePrediction.text === 'string') {
                                textValue = placePrediction.text;
                              } else if (placePrediction.text?.text) {
                                textValue = placePrediction.text.text;
                              }
                            }
                            if (!textValue && placePrediction?.description) {
                              textValue = typeof placePrediction.description === 'string' 
                                ? placePrediction.description 
                                : (placePrediction.description?.text || '');
                            }
                            if (!textValue && suggestion.text) {
                              textValue = typeof suggestion.text === 'string' 
                                ? suggestion.text 
                                : (suggestion.text?.text || '');
                            }
                            if (!textValue && suggestion.description) {
                              textValue = typeof suggestion.description === 'string' 
                                ? suggestion.description 
                                : (suggestion.description?.text || '');
                            }
                            
                            // Handle placeId property - could be placeId or place_id
                            let placeId = '';
                            if (placePrediction?.placeId) {
                              placeId = String(placePrediction.placeId);
                            } else if (placePrediction?.place_id) {
                              placeId = String(placePrediction.place_id);
                            } else if (suggestion.placeId) {
                              placeId = String(suggestion.placeId);
                            } else if (suggestion.place_id) {
                              placeId = String(suggestion.place_id);
                            }
                            
                            debugLog('[rocPlaces] Suggestion', index, 'extracted - textValue:', textValue, 'placeId:', placeId);
                            
                            // Log first item details
                            if (index === 0) {
                              console.log('[rocPlaces] First suggestion - textValue:', textValue, 'placeId:', placeId);
                              console.log('[rocPlaces] First suggestion extracted:', {
                                textValue: textValue,
                                placeId: placeId,
                                hasText: !!textValue,
                                hasPlaceId: !!placeId
                              });
                            }
                            
                            const result = {
                              description: textValue,
                              place_id: placeId,
                              structured_formatting: textValue
                                ? {
                                    main_text: textValue,
                                    secondary_text: '',
                                  }
                                : null,
                            };
                            
                            const hasRequiredFields = !!(result.place_id && result.description);
                            debugLog('[rocPlaces] Suggestion', index, 'mapped result:', result);
                            debugLog('[rocPlaces] Suggestion', index, 'has required fields:', hasRequiredFields);
                            
                            if (!hasRequiredFields) {
                              console.warn('[rocPlaces] Suggestion', index, 'will be filtered - missing place_id or description');
                            }
                            
                            return result;
                          }).filter(function(item, index) {
                            const keep = !!(item.place_id && item.description);
                            if (!keep && index < 3) {
                              console.warn('[rocPlaces] Filtering out item', index, '- place_id:', item.place_id, 'description:', item.description);
                            }
                            return keep;
                          });
                          
                          console.log('[rocPlaces] After filtering:', mapped.length, 'suggestions remain');
                          if (mapped.length > 0) {
                            console.log('[rocPlaces] Final mapped array (first 3):', JSON.stringify(mapped.slice(0, 3), null, 2));
                          } else {
                            console.warn('[rocPlaces] WARNING: All suggestions were filtered out!');
                            console.warn('[rocPlaces] Original suggestions count:', response.suggestions.length);
                          }
                          
                          console.log('[rocPlaces] Returning', mapped.length, 'mapped suggestions');
                          
                          if (onSuccess && typeof onSuccess === 'function') {
                            console.log('[rocPlaces] onSuccess is function:', typeof onSuccess);
                            console.log('[rocPlaces] Calling onSuccess with', mapped.length, 'items');
                            
                            // Log the actual array being passed
                            console.log('[rocPlaces] Array to pass:', mapped);
                            
                            try {
                              onSuccess(mapped);
                              console.log('[rocPlaces] onSuccess callback completed - no errors');
                            } catch (error) {
                              console.error('[rocPlaces] ERROR calling onSuccess:', error);
                              console.error('[rocPlaces] Error message:', error.message);
                              console.error('[rocPlaces] Error stack:', error.stack);
                              if (onError && typeof onError === 'function') {
                                onError('Failed to process autocomplete results: ' + (error.message || error));
                              }
                            }
                          } else {
                            console.error('[rocPlaces] ERROR: onSuccess is not a function!', typeof onSuccess);
                          }
                          return;
                        }
                        console.warn('[rocPlaces] AutocompleteSuggestion returned no suggestions or invalid response structure');
                        console.warn('[rocPlaces] Response was:', response);
                        if (onSuccess && typeof onSuccess === 'function') {
                          try {
                            onSuccess([]);
                          } catch (error) {
                            console.error('[rocPlaces] Error calling onSuccess with empty array:', error);
                          }
                        }
                      })
                      .catch(function(error) {
                        // Fallback to legacy API if new API fails
                        console.warn('[rocPlaces] New AutocompleteSuggestion API failed, using legacy:', error);
                        debugError('[rocPlaces] Error details:', error.message, error.stack);
                        // Continue to legacy API fallback below
                        _tryLegacyAutocomplete();
                      });
                  } catch (error) {
                    // Fallback to legacy API if new API fails
                    console.warn('[rocPlaces] New AutocompleteSuggestion API failed, using legacy:', error);
                    debugError('[rocPlaces] Error details:', error.message, error.stack);
                    _tryLegacyAutocomplete();
                  }
                } else {
                  _tryLegacyAutocomplete();
                }
                
                function _tryLegacyAutocomplete() {
                  // Legacy AutocompleteService fallback
                  if (window.google.maps.places.AutocompleteService) {
                    debugLog('[rocPlaces] Using legacy AutocompleteService');
                    const autocompleteService = new google.maps.places.AutocompleteService();
                    autocompleteService.getPlacePredictions(
                      {
                        input: query,
                        sessionToken: getSessionToken(),
                        componentRestrictions: { country: 'za' },
                      },
                      function (predictions, status) {
                        debugLog('[rocPlaces] Legacy API status:', status);
                        debugLog('[rocPlaces] Legacy API predictions:', predictions);
                        debugLog('[rocPlaces] Legacy API predictions count:', predictions?.length || 0);
                        if (
                          status !== google.maps.places.PlacesServiceStatus.OK ||
                          !predictions
                        ) {
                          debugError('[rocPlaces] Legacy API error:', status);
                          debugError('[rocPlaces] Legacy API predictions was:', predictions);
                          const errorMessage = status || 'Autocomplete request failed';
                          if (onError && typeof onError === 'function') {
                            onError(errorMessage);
                          }
                          return;
                        }
                        debugLog('[rocPlaces] Legacy API mapping', predictions.length, 'predictions');
                        const mapped = predictions.map(function(prediction, index) {
                          debugLog('[rocPlaces] Legacy prediction', index, ':', prediction);
                          const mapped = mapPrediction(prediction);
                          debugLog('[rocPlaces] Legacy prediction', index, 'mapped to:', mapped);
                          return mapped;
                        }).filter(function(p, index) {
                          const keep = p !== null && p.place_id && p.description;
                          if (!keep) {
                            console.warn('[rocPlaces] Legacy filtering out prediction', index, '- place_id:', p?.place_id, 'description:', p?.description);
                          }
                          return keep;
                        });
                        console.log('[rocPlaces] Legacy API returning', mapped.length, 'mapped predictions');
                        console.log('[rocPlaces] Legacy API final mapped array:', JSON.stringify(mapped, null, 2));
                        if (onSuccess && typeof onSuccess === 'function') {
                          console.log('[rocPlaces] onSuccess is function (legacy):', typeof onSuccess);
                          console.log('[rocPlaces] Calling onSuccess with array length (legacy):', mapped.length);
                          try {
                            const testResult = onSuccess.call ? 'has call method' : 'no call method';
                            console.log('[rocPlaces] Callback test (legacy):', testResult);
                            console.log('[rocPlaces] First item sample (legacy):', mapped.length > 0 ? JSON.stringify(mapped[0]) : 'empty array');
                            onSuccess(mapped);
                            console.log('[rocPlaces] onSuccess callback completed (legacy)');
                          } catch (error) {
                            console.error('[rocPlaces] Error calling onSuccess callback (legacy):', error);
                            console.error('[rocPlaces] Error stack:', error.stack);
                            if (onError && typeof onError === 'function') {
                              onError('Failed to process autocomplete results: ' + (error.message || error));
                            }
                          }
                        }
                      }
                    );
                  } else {
                    debugError('[rocPlaces] No autocomplete API available');
                    const error = 'No autocomplete API available';
                    if (onError && typeof onError === 'function') {
                      onError(error);
                    }
                  }
                }
              })
              .catch(function(error) {
                debugError('[rocPlaces] Error in autocomplete:', error);
                const errorMessage = error && error.message ? error.message : (error ? String(error) : 'Unknown error');
                if (onError && typeof onError === 'function') {
                  onError(errorMessage);
                }
              });
          } catch (error) {
            // Synchronous error - call error callback immediately
            debugError('[rocPlaces] Synchronous error in autocomplete wrapper:', error);
            const errorMessage = error && error.message ? error.message : (error ? String(error) : 'Unknown error');
            if (onError && typeof onError === 'function') {
              onError(errorMessage);
            }
          }
        },
        placeDetails: function (placeId, onSuccess, onError) {
          // Callback-based approach to avoid promise conversion issues with minified code
          try {
            if (!placeId) {
              const error = 'INVALID_PLACE_ID';
              debugError('[rocPlaces] ' + error);
              if (onError && typeof onError === 'function') {
                onError(error);
              }
              return;
            }
            if (!cachedKey) {
              const error = 'Places API not initialized';
              debugError('[rocPlaces] ' + error);
              if (onError && typeof onError === 'function') {
                onError(error);
              }
              return;
            }
            
            // Call ensurePlacesReady and handle with callbacks
            ensurePlacesReady(cachedKey)
              .then(function() {
                debugLog('[rocPlaces] Fetching place details for placeId:', placeId);
                debugLog('[rocPlaces] Place API available:', !!window.google.maps.places.Place);
                debugLog('[rocPlaces] PlacesService available:', !!window.google.maps.places.PlacesService);
                
                // Use new Place API if available, fallback to legacy
                if (
                  window.google.maps.places.Place &&
                  typeof window.google.maps.places.Place === 'function'
                ) {
                  try {
                    debugLog('[rocPlaces] Attempting to use Place API');
                    const place = new window.google.maps.places.Place({ id: placeId });
                    const fields = [
                      'addressComponents',
                      'geometry',
                      'formattedAddress',
                    ];
                    place.fetchFields({ fields: fields })
                      .then(function() {
                        debugLog('[rocPlaces] Place API response:', {
                          formattedAddress: place.formattedAddress,
                          hasGeometry: !!place.geometry,
                          hasAddressComponents: !!place.addressComponents,
                        });
                        
                        // Handle different possible location formats
                        let location = null;
                        if (place.geometry?.location) {
                          const loc = place.geometry.location;
                          if (typeof loc.lat === 'function' && typeof loc.lng === 'function') {
                            location = {
                              lat: loc.lat(),
                              lng: loc.lng(),
                            };
                          } else if (typeof loc.lat === 'number' && typeof loc.lng === 'number') {
                            location = {
                              lat: loc.lat,
                              lng: loc.lng,
                            };
                          }
                        }
                        
                        const result = {
                          formatted_address: place.formattedAddress || '',
                          geometry: location ? { location: location } : null,
                          address_components: mapAddressComponents(
                            place.addressComponents || []
                          ),
                        };
                        debugLog('[rocPlaces] Place API returning:', result);
                        resetSessionToken();
                        if (onSuccess && typeof onSuccess === 'function') {
                          onSuccess(result);
                        }
                      })
                      .catch(function(error) {
                        // Fallback to legacy API if new API fails
                        debugError('[rocPlaces] New Place API failed:', error);
                        debugError('[rocPlaces] Error name:', error?.name);
                        debugError('[rocPlaces] Error message:', error?.message);
                        debugError('[rocPlaces] Error stack:', error?.stack);
                        debugError('[rocPlaces] PlaceId used:', placeId);
                        // Log additional error properties if available
                        if (error && typeof error === 'object') {
                          debugError('[rocPlaces] Error properties:', Object.keys(error));
                          for (const key in error) {
                            if (error.hasOwnProperty(key)) {
                              debugError(`[rocPlaces] Error.${key}:`, error[key]);
                            }
                          }
                        }
                        // Continue to legacy API fallback below
                        _tryLegacyPlaceDetails();
                      });
                  } catch (error) {
                    // Fallback to legacy API if new API fails
                    debugError('[rocPlaces] New Place API failed:', error);
                    _tryLegacyPlaceDetails();
                  }
                } else {
                  _tryLegacyPlaceDetails();
                }
                
                function _tryLegacyPlaceDetails() {
                  // Legacy PlacesService fallback
                  if (window.google.maps.places.PlacesService) {
                    debugLog('[rocPlaces] Using legacy PlacesService');
                    const div = document.createElement('div');
                    const placesService = new google.maps.places.PlacesService(div);
                    placesService.getDetails(
                      {
                        placeId: placeId,
                        fields: ['address_components', 'geometry', 'formatted_address'],
                        sessionToken: getSessionToken(),
                      },
                      function (result, status) {
                        debugLog('[rocPlaces] Legacy API status:', status);
                        debugLog('[rocPlaces] Legacy API result:', result ? 'received' : 'null');
                        if (
                          status !== google.maps.places.PlacesServiceStatus.OK ||
                          !result
                        ) {
                          debugError('[rocPlaces] Legacy API error:', status);
                          const errorMessage = status || 'Place details request failed';
                          resetSessionToken();
                          if (onError && typeof onError === 'function') {
                            onError(errorMessage);
                          }
                          return;
                        }
                        const location =
                          result.geometry && result.geometry.location
                            ? {
                                lat: result.geometry.location.lat(),
                                lng: result.geometry.location.lng(),
                              }
                            : null;
                        const mappedResult = {
                          formatted_address: result.formatted_address || '',
                          geometry: location ? { location: location } : null,
                          address_components: mapAddressComponents(
                            result.address_components || []
                          ),
                        };
                        debugLog('[rocPlaces] Legacy API returning:', mappedResult);
                        resetSessionToken();
                        if (onSuccess && typeof onSuccess === 'function') {
                          onSuccess(mappedResult);
                        }
                      }
                    );
                  } else {
                    debugError('[rocPlaces] No place details API available');
                    const error = 'No place details API available';
                    if (onError && typeof onError === 'function') {
                      onError(error);
                    }
                  }
                }
              })
              .catch(function(error) {
                debugError('[rocPlaces] Error in placeDetails:', error);
                const errorMessage = error && error.message ? error.message : (error ? String(error) : 'Unknown error');
                if (onError && typeof onError === 'function') {
                  onError(errorMessage);
                }
              });
          } catch (error) {
            // Synchronous error - call error callback immediately
            debugError('[rocPlaces] Synchronous error in placeDetails wrapper:', error);
            const errorMessage = error && error.message ? error.message : (error ? String(error) : 'Unknown error');
            if (onError && typeof onError === 'function') {
              onError(errorMessage);
            }
          }
        },
      };
      })();
      
      console.log('[rocPlaces] rocPlaces initialized successfully:', typeof window.rocPlaces);
      console.log('[rocPlaces] rocPlaces has ensureLoaded:', typeof window.rocPlaces?.ensureLoaded);
      console.log('[rocPlaces] rocPlaces has autocomplete:', typeof window.rocPlaces?.autocomplete);
    } catch (error) {
      console.error('[rocPlaces] ERROR initializing rocPlaces:', error);
      console.error('[rocPlaces] Error stack:', error.stack);
      // Set to null so we know it failed
      window.rocPlaces = null;
    }
  </script>
  <script>
    // Helper functions for Dart JS interop to check Maps API availability
    window.rocMapsAPI = {
      isReady: function() {
        return !!(window.google && 
                  window.google.maps && 
                  window.google.maps.Map &&
                  typeof window.google.maps.Map === 'function' &&
                  window.google.maps.LatLng &&
                  typeof window.google.maps.LatLng === 'function');
      },
      getMapClass: function() {
        return window.google?.maps?.Map;
      },
      getLatLngClass: function() {
        return window.google?.maps?.LatLng;
      },
      getGeocoderClass: function() {
        return window.google?.maps?.Geocoder;
      },
      getMapTypeId: function() {
        return window.google?.maps?.MapTypeId;
      },
      getMapTypeIdRoadmap: function() {
        return window.google?.maps?.MapTypeId?.ROADMAP;
      },
      getMapsObject: function() {
        return window.google?.maps;
      },
      createLatLng: function(lat, lng) {
        if (!window.google || !window.google.maps || !window.google.maps.LatLng) {
          throw new Error('Google Maps LatLng not available');
        }
        return new window.google.maps.LatLng(lat, lng);
      },
      createMap: function(container, options) {
        if (!window.google || !window.google.maps || !window.google.maps.Map) {
          throw new Error('Google Maps Map not available');
        }
        return new window.google.maps.Map(container, options);
      },
      createMarker: function(options) {
        if (!window.google || !window.google.maps || !window.google.maps.Marker) {
          throw new Error('Google Maps Marker not available');
        }
        return new window.google.maps.Marker(options);
      },
      createMapWithClickListener: function(container, options, onClickCallback) {
        if (!window.google || !window.google.maps || !window.google.maps.Map) {
          throw new Error('Google Maps Map not available');
        }
        const map = new window.google.maps.Map(container, options);
        
        if (onClickCallback && typeof onClickCallback === 'function') {
          map.addListener('click', function(event) {
            const lat = event.latLng.lat();
            const lng = event.latLng.lng();
            onClickCallback(lat, lng);
          });
        }
        
        return map;
      },
      createMapWithMultipleMarkers: function(container, options, markers, onMarkerClick) {
        if (!window.google || !window.google.maps || !window.google.maps.Map) {
          throw new Error('Google Maps Map not available');
        }
        
        const map = new window.google.maps.Map(container, options);
        const markerInstances = [];
        
        // Parse markers if it's a JSON string, otherwise use as-is
        let markersArray = markers;
        if (typeof markers === 'string') {
          try {
            markersArray = JSON.parse(markers);
            debugLog('[rocMapsAPI] Parsed JSON markers string, got', markersArray.length, 'markers');
          } catch (e) {
            debugError('[rocMapsAPI] Failed to parse markers JSON:', e);
            return map;
          }
        }
        
        // Helper function to validate and convert coordinates
        function validateCoordinate(value, min, max, name) {
          debugLog('[rocMapsAPI] Validating coordinate', name + ':', value, 'type:', typeof value);
          const num = Number(value);
          if (isNaN(num) || !isFinite(num)) {
            console.warn('[rocMapsAPI] Invalid coordinate ' + name + ':', value, '(not a number, converted to:', num + ')');
            return null;
          }
          if (num < min || num > max) {
            console.warn('[rocMapsAPI] Invalid coordinate ' + name + ':', num, '(out of range: ' + min + ' to ' + max + ')');
            return null;
          }
          return num;
        }
        
        // Create markers
        if (markersArray && Array.isArray(markersArray)) {
          debugLog('[rocMapsAPI] Creating map with', markersArray.length, 'markers');
          let validMarkers = 0;
          let skippedMarkers = 0;
          
          markersArray.forEach(function(markerData) {
            // Validate and convert coordinates
            const lat = validateCoordinate(markerData.lat, -90, 90, 'lat');
            const lng = validateCoordinate(markerData.lng, -180, 180, 'lng');
            
            if (lat === null || lng === null) {
              console.warn('[rocMapsAPI] Skipping invalid marker:', {
                claimId: markerData.claimId,
                claimNumber: markerData.claimNumber,
                lat: markerData.lat,
                lng: markerData.lng,
                latType: typeof markerData.lat,
                lngType: typeof markerData.lng,
                fullMarkerData: JSON.stringify(markerData)
              });
              skippedMarkers++;
              return; // Skip this marker
            }
            
            try {
              // Determine marker style based on technician assignment
              const hasTechnician = markerData.hasTechnician === true || (markerData.technicianId && markerData.technicianName);
              const strokeColor = hasTechnician ? '#4CAF50' : '#FFFFFF'; // Green border for assigned
              const strokeWeight = hasTechnician ? 3 : 2; // Thicker border for assigned
              
              const marker = new window.google.maps.Marker({
                position: {
                  lat: lat,
                  lng: lng
                },
                map: map,
                title: markerData.title || markerData.claimNumber || '',
                icon: {
                  path: window.google.maps.SymbolPath.CIRCLE,
                  scale: 8,
                  fillColor: markerData.color || '#FF0000',
                  fillOpacity: 1,
                  strokeColor: strokeColor,
                  strokeWeight: strokeWeight,
                },
                label: {
                  text: markerData.claimNumber ? markerData.claimNumber.substring(0, 1).toUpperCase() : '',
                  color: '#FFFFFF',
                  fontSize: '10px',
                  fontWeight: 'bold',
                }
              });
              
              // Create info window content with technician info
              if (hasTechnician && markerData.technicianName) {
                const infoContent = '<div style="padding: 8px; font-family: Arial, sans-serif;">' +
                  '<div style="font-weight: bold; margin-bottom: 4px;">' + (markerData.claimNumber || '') + '</div>' +
                  '<div style="font-size: 12px; color: #666;">Technician: ' + markerData.technicianName + '</div>' +
                  '</div>';
                
                const infoWindow = new window.google.maps.InfoWindow({
                  content: infoContent
                });
                
                marker.addListener('click', function() {
                  infoWindow.open(map, marker);
                  if (onMarkerClick && markerData.claimId) {
                    if (typeof onMarkerClick === 'function') {
                      onMarkerClick(markerData.claimId);
                    } else if (typeof onMarkerClick === 'string') {
                      const callback = window[onMarkerClick];
                      if (typeof callback === 'function') {
                        callback(markerData.claimId);
                      }
                    }
                  }
                });
              } else {
                // No technician - just handle click
                if (onMarkerClick && markerData.claimId) {
                  marker.addListener('click', function() {
                    if (typeof onMarkerClick === 'function') {
                      onMarkerClick(markerData.claimId);
                    } else if (typeof onMarkerClick === 'string') {
                      const callback = window[onMarkerClick];
                      if (typeof callback === 'function') {
                        callback(markerData.claimId);
                      }
                    }
                  });
                }
              }
              
              markerInstances.push(marker);
              validMarkers++;
            } catch (error) {
              debugError('[rocMapsAPI] Error creating marker:', error, markerData);
              skippedMarkers++;
            }
          });
          
          debugLog('[rocMapsAPI] Marker creation complete:', validMarkers, 'valid,', skippedMarkers, 'skipped');
        }
        
        // Fit bounds to show all markers if there are any
        if (markerInstances.length > 0) {
          const bounds = new window.google.maps.LatLngBounds();
          markerInstances.forEach(function(marker) {
            bounds.extend(marker.getPosition());
          });
          
          // Only fit bounds if we have multiple markers, otherwise use initial center/zoom
          if (markerInstances.length > 1) {
            map.fitBounds(bounds);
          }
        }
        
        // Store markers in map instance for later updates
        map._markers = markerInstances;
        
        return map;
      },
      updateMarkers: function(mapInstance, markers) {
        if (!mapInstance || !mapInstance._markers) {
          debugError('[rocMapsAPI] Map instance or markers not available');
          return;
        }
        
        // Parse markers if it's a JSON string, otherwise use as-is
        let markersArray = markers;
        if (typeof markers === 'string') {
          try {
            markersArray = JSON.parse(markers);
            debugLog('[rocMapsAPI] Parsed JSON markers string for update, got', markersArray.length, 'markers');
          } catch (e) {
            debugError('[rocMapsAPI] Failed to parse markers JSON:', e);
            return;
          }
        }
        
        // Helper function to validate and convert coordinates
        function validateCoordinate(value, min, max, name) {
          debugLog('[rocMapsAPI] Validating coordinate', name + ':', value, 'type:', typeof value);
          const num = Number(value);
          if (isNaN(num) || !isFinite(num)) {
            console.warn('[rocMapsAPI] Invalid coordinate ' + name + ':', value, '(not a number, converted to:', num + ')');
            return null;
          }
          if (num < min || num > max) {
            console.warn('[rocMapsAPI] Invalid coordinate ' + name + ':', num, '(out of range: ' + min + ' to ' + max + ')');
            return null;
          }
          return num;
        }
        
        // Remove existing markers
        mapInstance._markers.forEach(function(marker) {
          marker.setMap(null);
        });
        mapInstance._markers = [];
        
        // Add new markers
        if (markersArray && Array.isArray(markersArray)) {
          debugLog('[rocMapsAPI] Updating map with', markersArray.length, 'markers');
          const bounds = new window.google.maps.LatLngBounds();
          let validMarkers = 0;
          let skippedMarkers = 0;
          
          markersArray.forEach(function(markerData) {
            // Validate and convert coordinates
            const lat = validateCoordinate(markerData.lat, -90, 90, 'lat');
            const lng = validateCoordinate(markerData.lng, -180, 180, 'lng');
            
            if (lat === null || lng === null) {
              console.warn('[rocMapsAPI] Skipping invalid marker in update:', {
                claimId: markerData.claimId,
                claimNumber: markerData.claimNumber,
                lat: markerData.lat,
                lng: markerData.lng,
                latType: typeof markerData.lat,
                lngType: typeof markerData.lng,
                fullMarkerData: JSON.stringify(markerData)
              });
              skippedMarkers++;
              return; // Skip this marker
            }
            
            try {
              // Determine marker style based on technician assignment
              const hasTechnician = markerData.hasTechnician === true || (markerData.technicianId && markerData.technicianName);
              const strokeColor = hasTechnician ? '#4CAF50' : '#FFFFFF'; // Green border for assigned
              const strokeWeight = hasTechnician ? 3 : 2; // Thicker border for assigned
              
              const marker = new window.google.maps.Marker({
                position: {
                  lat: lat,
                  lng: lng
                },
                map: mapInstance,
                title: markerData.title || markerData.claimNumber || '',
                icon: {
                  path: window.google.maps.SymbolPath.CIRCLE,
                  scale: 8,
                  fillColor: markerData.color || '#FF0000',
                  fillOpacity: 1,
                  strokeColor: strokeColor,
                  strokeWeight: strokeWeight,
                },
                label: {
                  text: markerData.claimNumber ? markerData.claimNumber.substring(0, 1).toUpperCase() : '',
                  color: '#FFFFFF',
                  fontSize: '10px',
                  fontWeight: 'bold',
                }
              });
              
              // Create info window content with technician info
              if (hasTechnician && markerData.technicianName) {
                const infoContent = '<div style="padding: 8px; font-family: Arial, sans-serif;">' +
                  '<div style="font-weight: bold; margin-bottom: 4px;">' + (markerData.claimNumber || '') + '</div>' +
                  '<div style="font-size: 12px; color: #666;">Technician: ' + markerData.technicianName + '</div>' +
                  '</div>';
                
                const infoWindow = new window.google.maps.InfoWindow({
                  content: infoContent
                });
                
                marker.addListener('click', function() {
                  infoWindow.open(mapInstance, marker);
                });
              }
              
              bounds.extend(marker.getPosition());
              mapInstance._markers.push(marker);
              validMarkers++;
            } catch (error) {
              debugError('[rocMapsAPI] Error creating marker:', error, markerData);
              skippedMarkers++;
            }
          });
          
          debugLog('[rocMapsAPI] Marker update complete:', validMarkers, 'valid,', skippedMarkers, 'skipped');
          
          // Fit bounds to show all markers
          if (mapInstance._markers.length > 0) {
            if (mapInstance._markers.length > 1) {
              mapInstance.fitBounds(bounds);
            } else {
              mapInstance.setCenter(mapInstance._markers[0].getPosition());
            }
          }
        }
      }
    };

    // Interactive Google Map widget functions
    window.rocMap = (function () {
      let mapInstances = {};
      let mapIdCounter = 0;

      function createMap(containerId, options) {
        if (!window.google || !window.google.maps) {
          debugError('[rocMap] Google Maps API not loaded');
          return null;
        }

        const container = document.getElementById(containerId);
        if (!container) {
          debugError('[rocMap] Container not found:', containerId);
          return null;
        }

        const mapOptions = {
          center: options.center || { lat: -25.7, lng: 28.2 }, // Default to South Africa
          zoom: options.zoom || 16,
          mapTypeId: google.maps.MapTypeId.ROADMAP,
          disableDefaultUI: false,
          zoomControl: true,
          mapTypeControl: false,
          scaleControl: true,
          streetViewControl: false,
          rotateControl: false,
          fullscreenControl: true,
        };

        const map = new google.maps.Map(container, mapOptions);
        let marker = null;

        // Add marker if coordinates provided
        if (options.marker && options.marker.lat && options.marker.lng) {
          marker = new google.maps.Marker({
            position: { lat: options.marker.lat, lng: options.marker.lng },
            map: map,
            draggable: options.marker.draggable || false,
            title: options.marker.title || 'Selected location',
          });

          // Center map on marker
          map.setCenter(marker.getPosition());
        }

        // Handle map click
        if (options.onClick) {
          map.addListener('click', function (event) {
            const lat = event.latLng.lat();
            const lng = event.latLng.lng();
            options.onClick(lat, lng);
          });
        }

        // Handle marker drag
        if (marker && options.onMarkerDrag) {
          marker.addListener('dragend', function (event) {
            const lat = event.latLng.lat();
            const lng = event.latLng.lng();
            options.onMarkerDrag(lat, lng);
          });
        }

        return {
          map: map,
          marker: marker,
          setCenter: function (lat, lng) {
            const center = new google.maps.LatLng(lat, lng);
            map.setCenter(center);
            if (marker) {
              marker.setPosition(center);
            }
          },
          setMarker: function (lat, lng, draggable) {
            const position = new google.maps.LatLng(lat, lng);
            if (marker) {
              marker.setPosition(position);
              marker.setDraggable(draggable || false);
            } else {
              marker = new google.maps.Marker({
                position: position,
                map: map,
                draggable: draggable || false,
                title: 'Selected location',
              });
            }
            map.setCenter(position);
          },
          removeMarker: function () {
            if (marker) {
              marker.setMap(null);
              marker = null;
            }
          },
          setZoom: function (zoom) {
            map.setZoom(zoom);
          },
        };
      }

      return {
        create: function (containerId, options) {
          return createMap(containerId, options);
        },
        generateId: function () {
          return 'roc-map-' + (++mapIdCounter);
        },
      };
    })();
  </script>
  <script src="flutter_bootstrap.js" async></script>
</body>
</html>
